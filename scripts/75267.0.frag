//GLSLプログラム自動生成システム試験中　by　ニシタマオ The Sea Panther
precision highp float;uniform vec4 UF_VP_Camera;uniform vec2 UF_V2Mohhuse;uniform float UF_nTime;vec4 JS_VResolution =vec4(800,600,0,0);const int JS_ciDefinition= int(30);const int JS_ciLights= int(0);float JS_nAerial = float(0);float JS_nHeightCeil = float(4);float JS_nHeightFloor = float(4);float JS_nDepthWallBack = float(4);float JS_nRefraction = float(0.5);int JS_iToon = int(0);vec4 JS_VP_Camera =vec4(0,0,4,0);vec4 JS_VP_Light =vec4(1,1,-1,0);vec4 JS_VC_Light =vec4(1,1,1,0);vec4 VColor_Default =vec4(1);float JS_nReflex_Default =float(1);float nReflex_Default =JS_nReflex_Default;float JS_nRandom = float(0.46127681073842397);uniform float time;uniform vec2 mouse;uniform vec2 resolution;float nTime =time;vec2 V2Resolution =resolution;uniform vec4 UF_aVP00[1];vec4 fVCalcPatternCeil(vec3 V3RL, vec3 V3P_Camera){ vec4 VP =vec4(V3RL, nTime); VP.xyz *= JS_nHeightCeil /VP.y; vec4 VC =vec4(0,0,0,0);VP.yz =VP.zy;vec2 V2P =VP.xy *0.2;for(int I =0; I <5; I++){ float nI =float(I +1); vec2 V2Ptmp =V2P; V2Ptmp.x += sin(nI *V2P.y+VP.w *1.0) /nI; V2Ptmp.y += sin(nI *V2P.x+VP.w *1.0) /nI; V2P =V2Ptmp;}VC.rgb =vec3(1) *sin(V2P.x);VC.rgb *=16.0 /length(VP.xyz); return VC;}vec4 fVCalcPatternFloor(vec3 V3RL, vec3 V3P_Camera){ vec4 VP =vec4(V3RL, nTime); VP.xyz *= -JS_nHeightFloor /VP.y; VP.xz += V3P_Camera.xz; vec4 VC =vec4(0,0,0,0);VP.yz =VP.zy;VC.rgb =vec3(1) *sign(sin(VP.x) *sin(VP.y -VP.w *1.0));VC.rgb *=16.0 /length(VP.xyz); return VC;}vec4 fVCalcReflect(vec3 V3NL, vec3 V3IP, vec3 V3P_Camera){ vec3 V3RL =reflect(normalize(V3IP +V3P_Camera), V3NL); return (V3RL.y >0.0)? fVCalcPatternCeil(V3RL, V3P_Camera):fVCalcPatternFloor(V3RL, V3P_Camera);}float fCalcMap(vec3 VP_Source){ float NP =0.0; vec4 VP =vec4(VP_Source, nTime);NP =-VP.z +float(1024);{}float NP_Previous =NP;vec4 VP_Keep =VP; { VP.xyz -= UF_aVP00[0].xyz;vec3 V3O =vec3(0,sin(VP.w *1.1),0), V3I =vec3(sin(VP.w *1.3), sin(VP.w *1.7), 0) *2.0, V3PO =VP.xyz -V3O, V3PI =VP.xyz -V3I;float nLO =length(V3PO), nLI =length(V3PI), nRatioO =nLI /(nLO +nLI), nRatioI =nLO /(nLO +nLI);float nPO =length(V3PO) -2.0;float nPI =length(V3PI) -1.0;NP =nPO *nRatioO +nPI *nRatioI; NP =min(NP, NP_Previous); NP_Previous =NP; VP =VP_Keep; }{ float NPA =-VP.z -float(-46); VColor_Default =(NPA <NP)? vec4(1):VColor_Default; nReflex_Default =(NPA <NP)? 1.0:nReflex_Default; NP =min(NP, NPA);}NP =max(NP, -VP.z -float(2)); return NP;}vec3 fV3CalcNormalLine(vec3 V3P){ float nNL =fCalcMap(V3P); float nD =1.0 /2560.0; vec3 V3NL =vec3(nNL); V3NL.x -=fCalcMap(V3P -vec3(nD,0,0)); V3NL.y -=fCalcMap(V3P -vec3(0,nD,0)); V3NL.z -=fCalcMap(V3P -vec3(0,0,nD)); V3NL =normalize(V3NL); return V3NL;}vec4 fVCalcLight(vec3 V3NL, vec3 V3IP){ vec4 VColor =vec4(0,0,0,1); float nLight =dot(V3NL, normalize(JS_VP_Light.xyz)); nLight =(nLight >0.0)? nLight:-nLight *0.2; VColor.rgb += nLight *JS_VC_Light.rgb; return VColor;}vec4 fVMain(vec2 V2UV){ vec3 V3Direction =normalize(vec3(V2UV, 1.0)); float nT =0.0; vec3 V3IP; vec4 VP_Camera =+JS_VP_Camera +UF_VP_Camera; for(int I=0; I <JS_ciDefinition; I++){ V3IP =V3Direction *nT -VP_Camera.xyz; nT +=fCalcMap(V3IP); if(abs(nT) <0.01) break; } vec3 V3NL =fV3CalcNormalLine(V3IP); vec4 VColor =fVCalcLight(V3NL, V3IP); vec4 VColorReflect =fVCalcReflect(V3NL, V3IP, VP_Camera.xyz); VColor.rgb *= VColorReflect.rgb *nReflex_Default +(1.0 -nReflex_Default); VColor.a *= -V3IP.z *JS_nAerial +1.0; VColor *= VColor_Default; return VColor;}void main(void){ vec2 uv =(2.0 *gl_FragCoord.xy -V2Resolution.xy) /min(V2Resolution.x, V2Resolution.y); gl_FragColor =fVMain(uv);}
