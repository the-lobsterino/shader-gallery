/*R040707作例　by ニシタマオ*//*サンドボックス上での試験用、簡易レイトレシステム、二段階反射機能付（R040628版）*/precision highp float;uniform vec2 resolution;uniform float time;uniform vec2 mouse;const bool cbSetting_March2nd =true;const bool cbSetting_Back =false;vec4 VDefaultCamera =vec4(0, 0, -20, 0);vec4 VDefaultLight =vec4(1,1,-1,0);struct scrd{	vec4 VColor;	float nReflex;	float nDistance;};scrd SCRD;vec4 VResolution =vec4(resolution, 0, 0);float nTime =time;vec4 VMouse =vec4(mouse *2.0 -1.0, 0, 0);/*文字列形状生成機能（R040630版）by ニシタマオ*/vec3 fV3LL(vec4 VP, vec4 VA, vec4 VB){	float nRadius =VA.w;	vec3 V3PA =VP.xyz -VA.xyz, V3BA =VB.xyz -VA.xyz;	float nA =clamp(dot(V3PA, V3BA) /dot(V3BA, V3BA), 0.0, 1.0);	vec3 V3P =V3PA -V3BA *nA;	return V3P;}float fNLL(vec4 VP, vec4 VA, vec4 VB){	float NP, nRadius =VA.w;	vec3 V3P =fV3LL(VP, VA, VB);/*	NP =length(V3P) -nRadius *0.75;*/	NP =abs(V3P.x) +abs(V3P.y) +abs(V3P.z) -nRadius *0.75;	return NP;}float fNLetters00(vec4 VP){	float NP =1000000.0;	{ vec3 V3C =vec3(7,7,3),  V3D =vec3(7,0,0), V3P;V3P.y +=V3C.y;V3P.x -=V3C.x; {   vec4 VP_Keep =VP;   VP.xyz -=V3P;{ vec4 VA, VB; VA.w =float(1);{ VA.xy =vec2(0,3); VB.xy =vec2(0,2); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(-3,1); VB.xy =vec2(-3,2); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(-3,2); VB.xy =vec2(3,2); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(3,2); VB.xy =vec2(3,1); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(-3,2); VB.xy =vec2(3,2); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(3,2); VB.xy =vec2(3,1); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(3,2); VB.xy =vec2(3,1); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(-3,0); VB.xy =vec2(3,0); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(0,1); VB.xy =vec2(-2,-1); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(-2,-1); VB.xy =vec2(2,-3); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(-2,-1); VB.xy =vec2(2,-3); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(2,0); VB.xy =vec2(-2,-3); NP =min(NP, fNLL(VP, VA, VB));}}   VP =VP_Keep; }V3P +=V3D; {   vec4 VP_Keep =VP;   VP.xyz -=V3P;{ vec4 VA, VB; VA.w =float(1);{ VA.xy =vec2(-1,3); VB.xy =vec2(-3,0); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(-2,1); VB.xy =vec2(-2,-3); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(1,3); VB.xy =vec2(1,2); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(-1,2); VB.xy =vec2(3,2); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(0,2); VB.xy =vec2(0,0); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(2,2); VB.xy =vec2(2,0); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(-1,0); VB.xy =vec2(3,0); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(0,-1); VB.xy =vec2(2,-1); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(2,-1); VB.xy =vec2(2,-3); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(2,-3); VB.xy =vec2(0,-3); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(0,-3); VB.xy =vec2(0,-1); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(2,-1); VB.xy =vec2(2,-3); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(2,-3); VB.xy =vec2(0,-3); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(0,-3); VB.xy =vec2(0,-1); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(2,-3); VB.xy =vec2(0,-3); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(0,-3); VB.xy =vec2(0,-1); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(0,-3); VB.xy =vec2(0,-1); NP =min(NP, fNLL(VP, VA, VB));}}   VP =VP_Keep; }V3P +=V3D;V3P =vec3(0);V3P.x -=V3C.x; {   vec4 VP_Keep =VP;   VP.xyz -=V3P;{ vec4 VA, VB; VA.w =float(1);{ VA.xy =vec2(-3,3); VB.xy =vec2(3,3); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(-3,0); VB.xy =vec2(3,0); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(-1,3); VB.xy =vec2(-1,0); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(1,3); VB.xy =vec2(1,0); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(-2,2); VB.xy =vec2(-1,0); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(2,2); VB.xy =vec2(1,0); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(-2,-1); VB.xy =vec2(2,-1); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(2,-1); VB.xy =vec2(2,-3); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(2,-3); VB.xy =vec2(-2,-3); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(-2,-3); VB.xy =vec2(-2,-1); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(2,-1); VB.xy =vec2(2,-3); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(2,-3); VB.xy =vec2(-2,-3); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(-2,-3); VB.xy =vec2(-2,-1); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(2,-3); VB.xy =vec2(-2,-3); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(-2,-3); VB.xy =vec2(-2,-1); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(-2,-3); VB.xy =vec2(-2,-1); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(-1,-2); VB.xy =vec2(1,-2); NP =min(NP, fNLL(VP, VA, VB));}}   VP =VP_Keep; }V3P +=V3D; {   vec4 VP_Keep =VP;   VP.xyz -=V3P;{ vec4 VA, VB; VA.w =float(1);{ VA.xy =vec2(-2,3); VB.xy =vec2(2,3); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(-2,0); VB.xy =vec2(2,0); NP =min(NP, fNLL(VP, VA, VB));}{ VA.xy =vec2(-3,-3); VB.xy =vec2(3,-3); NP =min(NP, fNLL(VP, VA, VB));}}   VP =VP_Keep; }V3P +=V3D;}	return NP;}vec3 fV3Rotate(vec3 V3P, vec3 V3R){	V3P.xy *=mat2(cos(V3R.z), -sin(V3R.z), sin(V3R.z), cos(V3R.z));	V3P.yz *=mat2(cos(V3R.x), -sin(V3R.x), sin(V3R.x), cos(V3R.x));	V3P.zx *=mat2(cos(V3R.y), -sin(V3R.y), sin(V3R.y), cos(V3R.y));	return V3P;}float fNCappedCylinder(vec4 VP, vec4 VA, vec4 VB){	float NP, nRadius =VA.w;	vec3 V3PA =VP.xyz -VA.xyz, V3BA =VB.xyz -VA.xyz;	float nBABA =dot(V3BA, V3BA), nPABA =dot(V3PA, V3BA);	float nX =length(V3PA *nBABA -V3BA *nPABA) -nRadius *nBABA;	float nY =abs(nPABA -nBABA *0.5) -nBABA *0.5;	float nXX =nX *nX, nYY =nY *nY;	float nD =(max(nX, nY) <0.0)? -min(nXX, nYY *nBABA):((nX >0.0)? nXX:0.0) +((nY >0.0) ?nYY *nBABA :0.0);	NP = sign(nD) *sqrt(abs(nD)) /nBABA;	return NP;}float fNCapsule(vec4 VP, vec4 VA, vec4 VB){	float NP, nRadius =VA.w;	vec3 V3PA =VP.xyz -VA.xyz, V3BA =VB.xyz -VA.xyz;	float nA =clamp(dot(V3PA, V3BA) /dot(V3BA, V3BA), 0.0, 1.0);	vec3 V3P =V3PA -V3BA *nA;	NP =length(V3P) -nRadius;	return NP;}float fNSmoothMin(float nP1, float nP2, float nK){	float nH =exp(-nP1 *nK) +exp(-nP2 *nK);	nH = -log(nH) /nK;	return nH;}float fNMap(vec3 V3P){	vec4 VP =vec4(V3P, nTime), VColor =vec4(1);	VP.zy *=mat2(cos(-0.25), -sin(-0.25), sin(-0.25), cos(-0.25));	VP.xz *=mat2(cos(VMouse.x), -sin(VMouse.x), sin(VMouse.x), cos(VMouse.x));	float NP =1000000.0, nReflex =1.0;	{		float nPP, nRL =1.0;		vec4 VC =vec4(1), VPA =VP;		VPA.y =mod(VPA.y -VP.w, 24.0) -12.0;		nPP =fNLetters00(VPA);		VC.rgb =sin(vec3(2,1,0) /3.0 *3.14 *2.0 -VP.w +VP.x +VP.y) *0.1 +0.9;		nRL =0.7;				VColor =(NP <nPP)?	VColor:VC;		nReflex =(NP <nPP)?	nReflex:nRL;		NP =min(NP, nPP);	}	{		float nPP, nRL =1.0, nRandom;		vec4 VC =vec4(1), VSeed =normalize(sqrt(vec4(2,3,5,7)));		vec3 V3P;		vec2 V2PMod =VP.xz -vec2(0.1,1) *VP.w, V2PDom =V2PMod;		V2PMod =mod(V2PMod, 16.0) -8.0, V2PDom -=V2PMod, nRandom =fract(sin(dot(V2PDom, VSeed.xy) *VSeed.z) +VSeed.w);		V3P =vec3(V2PMod.x, VP.y +sin((VP.w *0.2 +nRandom) *acos(-1.0)) *6.0, V2PMod.y);		V3P.zy *= mat2(cos(VP.w), -sin(VP.w), sin(VP.w), cos(VP.w));		nPP =length(max(abs(V3P) -2.0, 0.0)) -0.1;		VC.rgb =sin((vec3(2,1,0) /3.0  +nRandom) *acos(-1.0) *2.0) *0.2 +0.8;		nRL =0.4;		VColor =(NP <nPP)?	VColor:VC;		nReflex =(NP <nPP)?	nReflex:nRL;		NP =min(NP, nPP);	}	{		float nPP, nRL =1.0;		vec4 VC =vec4(1);		nPP =abs(VP.y +3.0) -0.5 +sin(VP.x +VP.z *0.5 +VP.w) *0.05 +sin(VP.z *0.2 +VP.x *0.1+VP.w *0.1) *0.1;		VC.rgb =sin(vec3(2,1,0) /3.0 *3.14 *2.0 -VP.w) *0.1 +0.9;		nRL =0.5;		VColor =(NP <nPP)?	VColor:VC;		nReflex =(NP <nPP)?	nReflex:nRL;		NP =fNSmoothMin(NP, nPP, 4.0);	}	SCRD.VColor  =VColor;	SCRD.nReflex =nReflex;	return NP;}vec4 fVCBack(vec3 V3D){	vec4 VP =vec4(V3D /V3D.y *4.0, nTime), VC =vec4(1);	if(V3D.y >0.0){		float nC;		nC =sin(VP.x) *sin(VP.z +VP.w);		VC.rgb = nC *sin(vec3(0,1,2) /3.0 *acos(-1.0) *2.0 +VP.w) *0.2 +0.8;	}else{		float nC;		nC =sign(sin(VP.x) *sin(VP.z +VP.w *0.1));		VC.rgb = nC *vec3(1) *0.2 +0.8;	}	VC.rgb +=length(VP.xz) *0.01;	return VC;}vec3 fV3NormalLine(vec3 V3P){	float nNL =fNMap(V3P);	float nD =1.0 /2560.0;	vec3 V3NL =vec3(nNL);	V3NL.x -=fNMap(V3P -vec3(nD,0,0));	V3NL.y -=fNMap(V3P -vec3(0,nD,0));	V3NL.z -=fNMap(V3P -vec3(0,0,nD));	V3NL =normalize(V3NL);	return V3NL;}void fMain(void){	vec2 V2UV =(gl_FragCoord.xy *2.0 -VResolution.xy) /max(VResolution.x, VResolution.y);	vec3 V3Camera =VDefaultCamera.xyz, V3Direction =normalize(vec3(V2UV, 1)), V3Light =VDefaultLight.xyz;	SCRD.VColor =vec4(1), SCRD.nReflex =1.0, SCRD.nDistance =1000000.0;	vec4 VColor =vec4(1);	const int ciDefinition =100;	float nDistance, nA, nT, nDistance_Max =100.0, nReflex =1.0;	int iTouch;	vec3 V3IP;	{		for(int I =0; I <ciDefinition; I++){			V3IP =V3Camera +nA *V3Direction;			nDistance =fNMap(V3IP);			nDistance =min(nDistance, 1.0);			SCRD.nDistance =min(SCRD.nDistance, nDistance);			if(nDistance <0.01){				iTouch++;				break;			}			if(nA >nDistance_Max)	break;			nA +=nDistance;			nT++;		}		if(iTouch >=1){			vec3 V3NL =fV3NormalLine(V3IP);			VColor.rgb *=dot(V3NL, normalize(V3Light)) *0.3 +0.7;			V3Direction =reflect(V3Direction, V3NL);			V3Camera =V3IP;			nA =0.02;			VColor *=SCRD.VColor;			nReflex =SCRD.nReflex;		}	}	if(cbSetting_March2nd){		for(int I =0; I <ciDefinition /2; I++){			V3IP =V3Camera +nA *V3Direction;			nDistance =fNMap(V3IP);			SCRD.nDistance =min(SCRD.nDistance, nDistance);			if(nDistance <0.01){				iTouch++;				break;			}			if(nA >nDistance_Max)	break;			nA +=nDistance;			nT++;		}		if(iTouch >=2){			VColor.rgb -=nT /float(ciDefinition /2) *0.3;			VColor *=(SCRD.VColor -1.0) *nReflex +1.0;			nReflex =0.0;		}	}	if(cbSetting_Back)	VColor *=(fVCBack(V3Direction) -1.0) *nReflex +1.0;		gl_FragColor =VColor;}void main(void){	fMain();}