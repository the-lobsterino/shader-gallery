//疑似レイトレーシング生成GLSLプログラム自動生成システム試験
precision highp float;uniform vec4 UF_VP_Camera;uniform vec2 UF_V2Mouse;uniform float UF_nTime;vec4 JS_VResolution =vec4(800,600,0,0);const int JS_ciDefinition= int(20);const int JS_ciLights= int(0);float JS_nAerial = float(0);float JS_nHeightCeil = float(4);float JS_nHeightFloor = float(4);float JS_nDepthWallBack = float(4);float JS_nRefraction = float(0.5);int JS_iToon = int(0);vec4 JS_VP_Camera =vec4(0,0,4,0);vec4 JS_VP_Light =vec4(1,1,-1,0);vec4 JS_VC_Light =vec4(1,1,1,0);vec4 VColor_Default =vec4(1);float JS_nReflex_Default =float(1);float nReflex_Default =JS_nReflex_Default;float JS_nRandom = float(0.13129251089465454);uniform float time;uniform vec2 mouse;uniform vec2 resolution;float nTime =time *100.0;vec2 V2Resolution =resolution;uniform vec4 UF_aVP00[1];vec4 fVCalcPatternCeil(vec3 V3RL, vec3 V3P_Camera){ vec4 VP =vec4(V3RL, nTime); VP.xyz *= JS_nHeightCeil /VP.y; vec4 VC =vec4(0,0,0,0);VP.yz =VP.zy;vec4 VRS =vec4(23,29,37,41);vec2 V2P =VP.xy -vec2(0,VP.w *0.01);float nC;for(int I =0; I <3; I++){ vec2 V2FR =fract(V2P), V2FL =floor(V2P); vec4 VW; VW.x =fract(sin(dot(V2FL +vec2(0,0), VRS.xy)) *VRS.z); VW.y =fract(sin(dot(V2FL +vec2(1,0), VRS.xy)) *VRS.z); VW.z =fract(sin(dot(V2FL +vec2(0,1), VRS.xy)) *VRS.z); VW.w =fract(sin(dot(V2FL +vec2(1,1), VRS.xy)) *VRS.z); VW.x *= (1.0 -V2FR.x) *(1.0 -V2FR.y); VW.y *= V2FR.x *(1.0 -V2FR.y); VW.z *= (1.0 -V2FR.x) *V2FR.y; VW.w *= V2FR.x *V2FR.y; nC +=(VW.x +VW.y +VW.z +VW.w) /4.0 /float(I +1); V2P *=2.0;}VC.rgb =vec3(1) *nC *2.0;VC.rgb *=16.0 /length(VP.xyz); return VC;}vec4 fVCalcPatternFloor(vec3 V3RL, vec3 V3P_Camera){ vec4 VP =vec4(V3RL, nTime); VP.xyz *= -JS_nHeightFloor /VP.y; VP.xz += V3P_Camera.xz; vec4 VC =vec4(0,0,0,0);VP.yz =VP.zy;VC.rgb =vec3(1) *sign(sin(VP.x) *sin(VP.y +VP.w*0.01));VC.rgb *=16.0 /length(VP.xyz); return VC;}vec4 fVCalcReflect(vec3 V3NL, vec3 V3IP, vec3 V3P_Camera){ vec3 V3RL =reflect(normalize(V3IP +V3P_Camera), V3NL); return (V3RL.y >0.0)? fVCalcPatternCeil(V3RL, V3P_Camera):fVCalcPatternFloor(V3RL, V3P_Camera);}float fCalcMap(vec3 VP_Source){ float NP =0.0; vec4 VP =vec4(VP_Source, nTime);NP =-VP.z +float(1024);{}float NP_Previous =NP;vec4 VP_Keep =VP; { VP.xyz -= UF_aVP00[0].xyz;{vec4 VP_Keep =VP; VP.y +=sin(VP.w *0.01) +3.0; vec3 V3C;float nP, nCheck, nRX =nReflex_Default;vec3 V3P;V3P =VP.xyz;NP =length(V3P) -1.5;nRX =0.5;V3C =vec3(0.1, 0.2, 1.0);nP =length(V3P.xy) -0.65;nCheck =step(0.0, nP);V3C =nCheck *V3C +(1.0 -nCheck) *vec3(1,1,1);nRX =nCheck *nRX +(1.0 -nCheck) *0.01;V3P.x =abs(V3P.x);V3P.xy -= vec2(0.2, 0.6);V3P.y *= 0.75;nP =length(V3P.xy) -0.2;nCheck =step(0.0, nP);V3C =nCheck *V3C +(1.0 -nCheck) *vec3(1,1,1);nRX =nCheck *nRX +(1.0 -nCheck) *0.01;V3P =VP.xyz;V3P.x =abs(V3P.x);V3P.xy -= vec2(0.1, 0.6);nP =length(V3P.xy) -0.06;nCheck =step(0.0, nP);V3C =nCheck *V3C +(1.0 -nCheck) *vec3(0.1,0.1,0.1);V3P =VP.xyz;V3P.y -= 0.3;nP =length(V3P.xy) -0.15;nCheck =step(0.0, nP);V3C =nCheck *V3C +(1.0 -nCheck) *vec3(1.0,0.2,0.1);V3P =VP.xyz;V3P.y -= -0.1;V3P.y *=step(-V3P.y ,0.0) *2.0+1.5;nP =length(V3P.xy) -0.5;nCheck =step(0.0, nP);V3C =nCheck *V3C +(1.0 -nCheck) *vec3(1.0,0.2,0.1);nReflex_Default =nRX;VColor_Default.rgb =V3C;VP =VP_Keep;}{vec4 VRS =vec4(23,29,37,41);vec2 V2P =VP.xz +vec2(0,VP.w *0.01);float nC;for(int I =0; I <3; I++){ vec2 V2FR =fract(V2P), V2FL =floor(V2P); vec4 VW; VW.x =fract(sin(dot(V2FL +vec2(0,0), VRS.xy)) *VRS.z); VW.y =fract(sin(dot(V2FL +vec2(1,0), VRS.xy)) *VRS.z); VW.z =fract(sin(dot(V2FL +vec2(0,1), VRS.xy)) *VRS.z); VW.w =fract(sin(dot(V2FL +vec2(1,1), VRS.xy)) *VRS.z); VW.x *= (1.0 -V2FR.x) *(1.0 -V2FR.y); VW.y *= V2FR.x *(1.0 -V2FR.y); VW.z *= (1.0 -V2FR.x) *V2FR.y; VW.w *= V2FR.x *V2FR.y; nC +=(VW.x +VW.y +VW.z +VW.w) /4.0 /float(I +1); V2P *=2.0;}float nP;nP =VP.y -nC +4.0 +sin(length(VP.zx) -VP.w *0.01);VColor_Default =vec4(1) *step(nP, NP) +VColor_Default *step(NP, nP);NP =min(NP, nP);} NP =min(NP, NP_Previous); NP_Previous =NP; VP =VP_Keep; }{ float NPA =-VP.z -float(-46); VColor_Default =(NPA <NP)? vec4(1):VColor_Default; nReflex_Default =(NPA <NP)? 1.0:nReflex_Default; NP =min(NP, NPA);}NP =max(NP, -VP.z -float(2)); return NP;}vec3 fV3CalcNormalLine(vec3 V3P){ float nNL =fCalcMap(V3P); float nD =1.0 /2560.0; vec3 V3NL =vec3(nNL); V3NL.x -=fCalcMap(V3P -vec3(nD,0,0)); V3NL.y -=fCalcMap(V3P -vec3(0,nD,0)); V3NL.z -=fCalcMap(V3P -vec3(0,0,nD)); V3NL =normalize(V3NL); return V3NL;}vec4 fVCalcLight(vec3 V3NL, vec3 V3IP){ vec4 VColor =vec4(0,0,0,1); float nLight =dot(V3NL, normalize(JS_VP_Light.xyz)); nLight =(nLight >0.0)? nLight:-nLight *0.2; VColor.rgb += nLight *JS_VC_Light.rgb; return VColor;}void main(void){ vec2 V2UV =(2.0 *gl_FragCoord.xy -V2Resolution.xy) /min(V2Resolution.x, V2Resolution.y); vec3 V3Direction =normalize(vec3(V2UV, 1.0)); float nT =0.0; vec3 V3IP; vec4 VP_Camera =+JS_VP_Camera +UF_VP_Camera; for(int I=0; I <JS_ciDefinition; I++){ V3IP =V3Direction *nT -VP_Camera.xyz; nT +=fCalcMap(V3IP); if(abs(nT) <0.01) break; } vec3 V3NL =fV3CalcNormalLine(V3IP); vec4 VColor =fVCalcLight(V3NL, V3IP); vec4 VColorReflect =fVCalcReflect(V3NL, V3IP, VP_Camera.xyz); VColor.rgb *= VColorReflect.rgb *nReflex_Default +(1.0 -nReflex_Default);gl_FragColor.a *= -V3IP.z *JS_nAerial +1.0;VColor.a *= -V3IP.z *JS_nAerial +1.0;VColor *= VColor_Default;gl_FragColor =VColor;}