//疑似レイトレ生成GLSLプログラム生成システム試験 Ver.0.1
precision highp float;uniform vec4 UF_VP_Camera;uniform vec2 UF_V2Mouse;uniform float UF_nTime;vec4 JS_VResolution =vec4(800,600,0,0);const int JS_ciDefinition= int(20);const int JS_ciLights= int(0);float JS_nAerial = float(0.03);float JS_nHeightCeil = float(4);float JS_nHeightFloor = float(4);float JS_nDepthWallBack = float(4);float JS_nRefraction = float(0.6);int JS_iToon = int(0);vec4 JS_VP_Camera =vec4(0,0,4,0);vec4 JS_VP_Light =vec4(1,1,-1,0);vec4 JS_VC_Light =vec4(1,1,1,0);vec4 VColor_Default =vec4(1);float JS_nRandom = float(0.33593146890417236);uniform float time;uniform vec2 mouse;uniform vec2 resolution;float nTime =time;vec2 V2Resolution =resolution;uniform vec4 UF_aVP00[1];vec4 fVCalcPatternWallBack(vec3 V3RL){ vec4 VP =vec4(V3RL, nTime); VP.xyz *= JS_nDepthWallBack /VP.z; vec4 VC =vec4(0,0,0,0);VC.rgb =vec3(sin(VP.x) *sin(VP.y +VP.w*0.1)); VC.rgb =max(VC.rgb, 0.5); return VC;}vec4 fVCalcRefract(vec3 V3NL, vec3 V3IP, vec3 V3P_Camera){ vec3 V3RL =refract(V3NL, normalize(V3IP +V3P_Camera) *2.0, JS_nRefraction); return fVCalcPatternWallBack(V3RL);}float fCalcMap(vec3 VP_Source){ float NP =0.0; vec4 VP =vec4(VP_Source, nTime);NP =-VP.z +float(16);{}float NP_Previous =NP;vec4 VP_Keep =VP; { VP.xyz -= UF_aVP00[0].xyz;VP.xy =mod(VP.xy, 4.0) -2.0;VP.z -=2.0;vec4 VA, VB, VC, VD;float nA, nB, nC, nD, nP;nP =length(VP.xyz) -1.0;NP =nP;nP =length((VP.xyz -vec3(0,-0,-1)) *vec3(1.2,1.2,1)) -0.6;NP =min(nP, NP);nP =length((VP.xyz -vec3(0,+0.3,-1.4))) -0.2;NP =min(nP, NP);nP =length((vec3(abs(VP.x),VP.yz) -vec3(+0.3,+0.7,-0.6))) -0.1;NP =min(nP, NP);VA =vec4(abs(VP.x), VP.yzw);VB.xyz =VA.xyz -vec3(0.5,0.5,0);VC.xyz =vec3(1.5,0,0) -vec3(0.5,0.5,0);nA =clamp(dot(VB.xyz, VC.xyz) /dot(VC.xyz, VC.xyz), 0.0, 1.0);nP =length(VB.xyz -VC.xyz *nA) -0.3;NP =min(nP, NP); NP =min(NP, NP_Previous); NP_Previous =NP; VP =VP_Keep; }NP =min(NP, -VP.z -float(-28));NP =max(NP, -VP.z -float(2)); return NP;}vec3 fV3CalcNormalLine(vec3 V3P){ float nNL =fCalcMap(V3P); float nD =1.0 /2560.0; vec3 V3NL =vec3(nNL); V3NL.x -=fCalcMap(V3P -vec3(nD,0,0)); V3NL.y -=fCalcMap(V3P -vec3(0,nD,0)); V3NL.z -=fCalcMap(V3P -vec3(0,0,nD)); V3NL =normalize(V3NL); return V3NL;}vec4 fVCalcLight(vec3 V3NL, vec3 V3IP){ vec4 VColor =vec4(0,0,0,1); float nLight =dot(V3NL, normalize(JS_VP_Light.xyz)); nLight =(nLight >0.0)? nLight:-nLight *0.2; VColor.rgb += nLight *JS_VC_Light.rgb; return VColor;}void main(void){ vec2 V2UV =(2.0 *gl_FragCoord.xy -V2Resolution.xy) /min(V2Resolution.x, V2Resolution.y); vec3 V3Direction =normalize(vec3(V2UV, 1.0)); float nT =0.0; vec3 V3IP; vec4 VP_Camera =+JS_VP_Camera +UF_VP_Camera; for(int I=0; I <JS_ciDefinition; I++){ V3IP =V3Direction *nT -VP_Camera.xyz; nT +=fCalcMap(V3IP); if(abs(nT) <0.01) break; } vec3 V3NL =fV3CalcNormalLine(V3IP); vec4 VColor =fVCalcLight(V3NL, V3IP); vec4 VColorRefract =fVCalcRefract(V3NL, V3IP, VP_Camera.xyz); VColor.rgb *= VColorRefract.rgb *1.0; VColor.rgb += VColorRefract.rgb *0.1;gl_FragColor.a *= -V3IP.z *JS_nAerial +1.0;VColor.a *= -V3IP.z *JS_nAerial +1.0;gl_FragColor =VColor;}