precision highp float;uniform vec4 UF_VP_Camera;uniform vec2 UF_V2Mouse;uniform float UF_nTime;vec4 JS_VResolution =vec4(800,600,0,0);const int JS_ciDefinition= int(20);const int JS_ciLights= int(0);float JS_nAerial = float(0.03);float JS_nHeightCeil = float(1);float JS_nHeightFloor = float(1);float JS_nDepthWallBack = float(1);float JS_nRefraction = float(0.5);int JS_iToon = int(0);vec4 JS_VP_Camera =vec4(0,0,4,0);vec4 JS_VP_Light =vec4(1,1,-1,0);vec4 JS_VC_Light =vec4(1,1,1,0);vec4 VColor_Default =vec4(1);float JS_nRandom = float(0.8619531349408183);uniform float time;uniform vec2 mouse;uniform vec2 resolution;float nTime =time;vec2 V2Resolution =resolution;uniform vec4 UF_aVP00[1];vec4 fVCalcPatternCeil(vec3 V3RL, vec3 V3P_Camera){ vec4 VP =vec4(V3RL, nTime); VP.xyz *= JS_nHeightCeil /VP.y; vec4 VC =vec4(0,0,0,0);VP.y =VP.z;vec4 VPP, VCC, VSeed =vec4(3579.3579, 5793.5793, 7935.7935, 9355.9357) *JS_nRandom;float nC00, nC10, nC01, nC11, nD00, nD10, nD01, nD11;const int ciCap =8;VPP.xyw =VP.xyw;VPP.y +=VPP.w *0.1;for(int I=0; I<ciCap; I++){ nD00 =(1.0 -fract(VPP.x)) *(1.0 -fract(VPP.y)); nD10 =fract(VPP.x) *(1.0 -fract(VPP.y)); nD01 =(1.0 -fract(VPP.x)) *fract(VPP.y); nD11 =fract(VPP.x) *fract(VPP.y); nC00 =fract(sin(dot(floor(VPP.xy ),VSeed.xy)) *VSeed.w) *nD00; nC10 =fract(sin(dot(floor(VPP.xy +vec2(1,0)),VSeed.xy)) *VSeed.w) *nD10; nC01 =fract(sin(dot(floor(VPP.xy +vec2(0,1)),VSeed.xy)) *VSeed.w) *nD01; nC11 =fract(sin(dot(floor(VPP.xy +vec2(1,1)),VSeed.xy)) *VSeed.w) *nD11; VCC.r +=(nC00 +nC10 +nC01 +nC11) /float(I +1); VSeed.xyzw =VSeed.yzwx; nC00 =fract(sin(dot(floor(VPP.xy ),VSeed.xy)) *VSeed.w) *nD00; nC10 =fract(sin(dot(floor(VPP.xy +vec2(1,0)),VSeed.xy)) *VSeed.w) *nD10; nC01 =fract(sin(dot(floor(VPP.xy +vec2(0,1)),VSeed.xy)) *VSeed.w) *nD01; nC11 =fract(sin(dot(floor(VPP.xy +vec2(1,1)),VSeed.xy)) *VSeed.w) *nD11; VCC.g +=(nC00 +nC10 +nC01 +nC11) /float(I +1); VSeed.xyzw =VSeed.yzwx; nC00 =fract(sin(dot(floor(VPP.xy ),VSeed.xy)) *VSeed.w) *nD00; nC10 =fract(sin(dot(floor(VPP.xy +vec2(1,0)),VSeed.xy)) *VSeed.w) *nD10; nC01 =fract(sin(dot(floor(VPP.xy +vec2(0,1)),VSeed.xy)) *VSeed.w) *nD01; nC11 =fract(sin(dot(floor(VPP.xy +vec2(1,1)),VSeed.xy)) *VSeed.w) *nD11; VCC.b +=(nC00 +nC10 +nC01 +nC11) /float(I +1); VPP.xy *= 2.0;}VCC.rgb /= 2.0 /(1.0 -1.0/float(ciCap));VC.rgb =VCC.rgb;VC.rgb *= 2.0 /length(VP.xy); return VC;}vec4 fVCalcPatternFloor(vec3 V3RL, vec3 V3P_Camera){ vec4 VP =vec4(V3RL, nTime); VP.xyz *= -JS_nHeightFloor /VP.y; VP.xz += V3P_Camera.xz; vec4 VC =vec4(0,0,0,0);VP.y =VP.z;VP.w =0.0;vec4 VPP, VCC, VSeed =vec4(3579.3579, 5793.5793, 7935.7935, 9355.9357) *JS_nRandom;float nC, nC00, nC10, nC01, nC11, nD00, nD10, nD01, nD11;const int ciCap =8;VPP.xyw =VP.xyw;VPP.y +=VPP.w *0.1;for(int I=0; I<ciCap; I++){ nD00 =(1.0 -fract(VPP.x)) *(1.0 -fract(VPP.y)); nD10 =fract(VPP.x) *(1.0 -fract(VPP.y)); nD01 =(1.0 -fract(VPP.x)) *fract(VPP.y); nD11 =fract(VPP.x) *fract(VPP.y); nC00 =fract(sin(dot(floor(VPP.xy ),VSeed.xy)) *VSeed.w) *nD00; nC10 =fract(sin(dot(floor(VPP.xy +vec2(1,0)),VSeed.xy)) *VSeed.w) *nD10; nC01 =fract(sin(dot(floor(VPP.xy +vec2(0,1)),VSeed.xy)) *VSeed.w) *nD01; nC11 =fract(sin(dot(floor(VPP.xy +vec2(1,1)),VSeed.xy)) *VSeed.w) *nD11; nC +=(nC00 +nC10 +nC01 +nC11) /float(I +1); VPP.xy *= 2.0;}nC /= 2.0 /(1.0 -1.0/float(ciCap));VC.rgb =vec3(nC);VC.rgb =step(0.5, VC.rgb);VC.rgb *= 2.0 /length(VP.xy -V3P_Camera.xz); return VC;}vec4 fVCalcReflect(vec3 V3NL, vec3 V3IP, vec3 V3P_Camera){ vec3 V3RL =reflect(V3NL, normalize(V3IP +V3P_Camera) *2.0); return (V3RL.y >0.0)? fVCalcPatternCeil(V3RL, V3P_Camera):fVCalcPatternFloor(V3RL, V3P_Camera);}float fCalcMap(vec3 VP_Source){ float NP =0.0; vec4 VP =vec4(VP_Source, nTime);NP =-VP.z +float(16);{}float NP_Previous =NP;vec4 VP_Keep =VP; { VP.xyz -= UF_aVP00[0].xyz;vec4 VSeed =vec4(11, 13, 17, 19); vec2 V2P =abs(VP.xz); V2P.x +=VP.w *0.1; float nP; for(int I =0; I <3; I++){ float nP00 =fract(sin(dot(floor(V2P), VSeed.xy)) *VSeed.w), nP10 =fract(sin(dot(floor(V2P +vec2(1,0)), VSeed.xy)) *VSeed.w), nP01 =fract(sin(dot(floor(V2P +vec2(0,1)), VSeed.xy)) *VSeed.w), nP11 =fract(sin(dot(floor(V2P +vec2(1,1)), VSeed.xy)) *VSeed.w); float nCosX0 =(cos(fract(V2P.x) *3.14) +1.0) /2.0, nCosX1 =(cos((1.0 -fract(V2P.x)) *3.14) +1.0) /2.0, nCosY0 =(cos(fract(V2P.y) *3.14) +1.0) /2.0, nCosY1 =(cos((1.0 -fract(V2P.y)) *3.14) +1.0) /2.0; nP00 *=nCosX0*nCosY0; nP10 *=nCosX1*nCosY0; nP01 *=nCosX0*nCosY1; nP11 *=nCosX1*nCosY1; nP += (nP00 +nP10 +nP01 +nP11) /float(I +1); V2P.xy *= 2.0; } NP =VP.y -nP /2.0; NP += 10.0/(1.0 +length(VP.x)) +sin(abs(VP.x) +VP.w *0.2) *0.2, NP =min(NP, VP.y +6.0); NP =min(NP, NP_Previous); NP_Previous =NP; VP =VP_Keep; }NP =min(NP, -VP.z -float(-28));NP =max(NP, -VP.z -float(2)); return NP;}vec3 fV3CalcNormalLine(vec3 V3P){ float nNL =fCalcMap(V3P); float nD =1.0 /2560.0; vec3 V3NL =vec3(nNL); V3NL.x -=fCalcMap(V3P -vec3(nD,0,0)); V3NL.y -=fCalcMap(V3P -vec3(0,nD,0)); V3NL.z -=fCalcMap(V3P -vec3(0,0,nD)); V3NL =normalize(V3NL); return V3NL;}vec4 fVCalcLight(vec3 V3NL, vec3 V3IP){ vec4 VColor =vec4(0,0,0,1); float nLight =dot(V3NL, normalize(JS_VP_Light.xyz)); nLight =(nLight >0.0)? nLight:-nLight *0.2; VColor.rgb += nLight *JS_VC_Light.rgb; return VColor;}void main(void){ vec2 V2UV =(2.0 *gl_FragCoord.xy -V2Resolution.xy) /min(V2Resolution.x, V2Resolution.y); vec3 V3Direction =normalize(vec3(V2UV, 1.0)); float nT =0.0; vec3 V3IP; vec4 VP_Camera =+JS_VP_Camera +UF_VP_Camera; for(int I=0; I <JS_ciDefinition; I++){ V3IP =V3Direction *nT -VP_Camera.xyz; nT +=fCalcMap(V3IP); if(abs(nT) <0.01) break; } vec3 V3NL =fV3CalcNormalLine(V3IP); vec4 VColor =fVCalcLight(V3NL, V3IP); vec4 VColorReflect =fVCalcReflect(V3NL, V3IP, VP_Camera.xyz); VColor.rgb *= VColorReflect.rgb *1.0; VColor.rgb += VColorReflect.rgb *0.1;gl_FragColor.a *= -V3IP.z *JS_nAerial +1.0;VColor.a *= -V3IP.z *JS_nAerial +1.0;gl_FragColor =VColor;}