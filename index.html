<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Shader Dive</title>
	<style>
		* { margin: 0; padding: 0; box-sizing: border-box; }
		html, body {
			width: 100%; height: 100%;
			overflow: hidden;
			background: #000;
		}
		#main-canvas {
			position: absolute;
			top: 0; left: 0;
			width: 100%;
			height: calc(100% - 80px);
		}
		#related-strip {
			position: absolute;
			bottom: 0; left: 0;
			width: 100%; height: 80px;
			display: flex;
			overflow-x: auto;
			overflow-y: hidden;
		}
		#related-strip::-webkit-scrollbar { display: none; }
		.related-canvas {
			height: 80px;
			flex-shrink: 0;
			cursor: pointer;
			transition: filter 0.2s;
		}
		.related-canvas:hover {
			filter: brightness(1.3);
		}
		#loading {
			position: absolute;
			top: 50%; left: 50%;
			transform: translate(-50%, -50%);
			color: #333;
			font-family: monospace;
		}
	</style>
</head>
<body>
	<canvas id="main-canvas"></canvas>
	<div id="related-strip"></div>
	<div id="loading">loading...</div>
	<script>
		const VERTEX_SRC = `attribute vec2 position;varying vec2 surfacePosition;uniform highp vec2 resolution;void main() {    surfacePosition = position * vec2(resolution.x/resolution.y, 1.0);    gl_Position = vec4(position, 0.0, 1.0);}`;
		const UNIFORM_HEADER = `precision highp float;uniform float time;uniform highp vec2 resolution;uniform vec2 mouse;varying vec2 surfacePosition;`;
		let manifest = [];
		let relations = {};
		let currentId = null;
		let mainCtx = null;
		let relatedCtxs = [];
		// === INIT ===
		async function init() {
			const [m, r] = await Promise.all([
				fetch('manifest.json').then(r => r.json()),
				fetch('relations.json').then(r => r.json()).catch(() => ({}))
			]);
			manifest = m.shaders || [];
			relations = r;
			document.getElementById('loading').remove();
			const startId = getHashId() || manifest[Math.floor(Math.random() * manifest.length)];
			loadShader(startId);
			window.addEventListener('resize', () => {
				if (mainCtx) resizeCanvas(mainCtx);
				relatedCtxs.forEach(ctx => resizeCanvas(ctx));
			});
			window.addEventListener('hashchange', () => {
				const id = getHashId();
				if (id && id !== currentId) loadShader(id);
			});
		}
		function getHashId() {
			const hash = window.location.hash.slice(1);
			return manifest.includes(hash) ? hash : null;
		}
		// === SHADER LOADING ===
		async function loadShader(id) {
			currentId = id;
			window.location.hash = id;
			const code = await fetch(`scripts/${id}.frag`).then(r => r.text()).catch(() => null);
			if (!code) return;
			if (mainCtx) destroyCtx(mainCtx);
			const mainCanvas = document.getElementById('main-canvas');
			mainCtx = createShaderCtx(mainCanvas, code);
			loadRelated(id);
		}
		async function loadRelated(id) {
			const strip = document.getElementById('related-strip');
			relatedCtxs.forEach(destroyCtx);
			relatedCtxs = [];
			strip.innerHTML = '';
			const relatedIds = relations[id] || [];
			if (relatedIds.length === 0) return;
			const canvasWidth = Math.max(120, Math.floor(window.innerWidth / Math.min(relatedIds.length, 8)));
			const codes = await Promise.all(
				relatedIds.map(rid =>
					fetch(`scripts/${rid}.frag`).then(r => r.text()).catch(() => null)
				)
			);
			relatedIds.forEach((rid, i) => {
				if (!codes[i]) return;
				const canvas = document.createElement('canvas');
				canvas.className = 'related-canvas';
				canvas.style.width = canvasWidth + 'px';
				canvas.dataset.id = rid;
				canvas.addEventListener('click', () => loadShader(rid));
				strip.appendChild(canvas);
				const ctx = createShaderCtx(canvas, codes[i]);
				if (ctx) relatedCtxs.push(ctx);
			});
		}
		// === WEBGL ===
		function createShaderCtx(canvas, fragCode) {
			const gl = canvas.getContext('webgl', { preserveDrawingBuffer: true });
			if (!gl) return null;
			resizeCanvas({ canvas, gl });
			const hasTime = /uniform\s+float\s+time/.test(fragCode);
			const hasRes = /uniform\s+vec2\s+resolution/.test(fragCode);
			const hasMouse = /uniform\s+vec2\s+mouse/.test(fragCode);
			const hasSurface = /varying\s+vec2\s+surfacePosition/.test(fragCode);
			if (hasRes) {
				fragCode = fragCode.replace(/uniform\s+vec2\s+resolution/g, 'uniform highp vec2 resolution');
			}
			let header = 'precision highp float;\n';
			if (!hasTime) header += 'uniform float time;\n';
			if (!hasRes) header += 'uniform highp vec2 resolution;\n';
			if (!hasMouse) header += 'uniform vec2 mouse;\n';
			if (!hasSurface) header += 'varying vec2 surfacePosition;\n';
			const wrapped = header + fragCode;
			try {
				const vs = compileShader(gl, gl.VERTEX_SHADER, VERTEX_SRC);
				const fs = compileShader(gl, gl.FRAGMENT_SHADER, wrapped);
				const program = gl.createProgram();
				gl.attachShader(program, vs);
				gl.attachShader(program, fs);
				gl.linkProgram(program);
				if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
					console.warn('Link failed:', canvas.dataset?.id);
					console.warn(gl.getProgramInfoLog(program));
					return null;
				}
				gl.useProgram(program);
				const buf = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, buf);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
				const pos = gl.getAttribLocation(program, 'position');
				gl.enableVertexAttribArray(pos);
				gl.vertexAttribPointer(pos, 2, gl.FLOAT, false, 0, 0);
				const ctx = {
					canvas, gl, program,
					uTime: gl.getUniformLocation(program, 'time'),
					uRes: gl.getUniformLocation(program, 'resolution'),
					uMouse: gl.getUniformLocation(program, 'mouse'),
					startTime: performance.now(),
					animId: null
				};
				function render() {
					if (!ctx.gl) return;
					const t = (performance.now() - ctx.startTime) / 1000;
					gl.uniform1f(ctx.uTime, t);
					gl.uniform2f(ctx.uRes, canvas.width, canvas.height);
					gl.uniform2f(ctx.uMouse, 0.5, 0.5);
					gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
					ctx.animId = requestAnimationFrame(render);
				}
				render();
				return ctx;
			} catch (e) {
				console.warn('Shader error:', canvas.dataset?.id, e.message);
				return null;
			}
		}
		function compileShader(gl, type, src) {
			const s = gl.createShader(type);
			gl.shaderSource(s, src);
			gl.compileShader(s);
			if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
				throw new Error(gl.getShaderInfoLog(s));
			}
			return s;
		}
		function resizeCanvas(ctx) {
			const { canvas, gl } = ctx;
			const dpr = window.devicePixelRatio || 1;
			const w = canvas.clientWidth * dpr;
			const h = canvas.clientHeight * dpr;
			if (canvas.width !== w || canvas.height !== h) {
				canvas.width = w;
				canvas.height = h;
				if (gl) gl.viewport(0, 0, w, h);
			}
		}
		function destroyCtx(ctx) {
			if (!ctx) return;
			if (ctx.animId) cancelAnimationFrame(ctx.animId);
			ctx.gl = null;
		}
		// === GO ===
		init();
	</script>
</body>
</html>
