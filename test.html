<!DOCTYPE html>
<html>
<head>
  <title>Shader Test</title>
  <style>
    body { margin: 0; background: #111; color: #fff; font-family: monospace; }
    canvas { display: block; width: 400px; height: 400px; margin: 20px auto; }
    #info { text-align: center; padding: 10px; }
    #error { color: #f55; white-space: pre-wrap; max-width: 800px; margin: 10px auto; }
    button { margin: 5px; padding: 10px 20px; cursor: pointer; }
  </style>
</head>
<body>
  <div id="info">
    <button onclick="loadRandom()">Random Shader</button>
    <button onclick="loadNext()">Next</button>
    <span id="current">-</span>
  </div>
  <canvas id="c" width="400" height="400"></canvas>
  <div id="error"></div>

  <script>
    const canvas = document.getElementById('c');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    const errorDiv = document.getElementById('error');
    const currentSpan = document.getElementById('current');
    
    let shaders = [];
    let currentIdx = 0;
    let program = null;
    let startTime = Date.now();
    let animFrame = null;
    let mouseX = 0, mouseY = 0;

    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      mouseX = (e.clientX - rect.left) / rect.width;
      mouseY = 1.0 - (e.clientY - rect.top) / rect.height;
    });

    // Vertex shader (fullscreen quad)
    const vertSrc = `
      attribute vec2 pos;
      void main() { gl_Position = vec4(pos, 0.0, 1.0); }
    `;

    // Standard GLSL Sandbox prefix
    const prefix = `
      #ifdef GL_ES
      precision mediump float;
      #endif
      uniform float time;
      uniform vec2 resolution;
      uniform vec2 mouse;
    `;

    async function loadManifest() {
      const resp = await fetch('manifest.json');
      const data = await resp.json();
      shaders = data.shaders;
      console.log(`Loaded ${shaders.length} shaders`);
      loadRandom();
    }

    function loadRandom() {
      currentIdx = Math.floor(Math.random() * shaders.length);
      loadShader(shaders[currentIdx]);
    }

    function loadNext() {
      currentIdx = (currentIdx + 1) % shaders.length;
      loadShader(shaders[currentIdx]);
    }

    async function loadShader(id) {
      errorDiv.textContent = '';
      currentSpan.textContent = `#${id}`;
      
      try {
        const resp = await fetch(`scripts/${id}.frag`);
        if (!resp.ok) throw new Error(`Failed to load ${id}`);
        let code = await resp.text();
        
        // Strip any existing precision/version declarations
        code = code.replace(/#ifdef GL_ES[\s\S]*?#endif/g, '');
        code = code.replace(/precision\s+\w+\s+float;/g, '');
        
        compileAndRun(prefix + code);
      } catch (e) {
        errorDiv.textContent = `Load error: ${e.message}`;
      }
    }

    function compileAndRun(fragSrc) {
      if (animFrame) cancelAnimationFrame(animFrame);
      if (program) gl.deleteProgram(program);

      const vs = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vs, vertSrc);
      gl.compileShader(vs);
      
      const fs = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fs, fragSrc);
      gl.compileShader(fs);
      
      if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
        errorDiv.textContent = gl.getShaderInfoLog(fs);
        return;
      }

      program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        errorDiv.textContent = gl.getProgramInfoLog(program);
        return;
      }

      // Setup fullscreen quad
      const buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
      
      const pos = gl.getAttribLocation(program, 'pos');
      gl.enableVertexAttribArray(pos);
      gl.vertexAttribPointer(pos, 2, gl.FLOAT, false, 0, 0);

      startTime = Date.now();
      render();
    }

    function render() {
      if (!program) return;
      
      gl.useProgram(program);
      
      const t = (Date.now() - startTime) / 1000;
      gl.uniform1f(gl.getUniformLocation(program, 'time'), t);
      gl.uniform2f(gl.getUniformLocation(program, 'resolution'), canvas.width, canvas.height);
      gl.uniform2f(gl.getUniformLocation(program, 'mouse'), mouseX, mouseY);
      
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      animFrame = requestAnimationFrame(render);
    }

    loadManifest();
  </script>
</body>
</html>
